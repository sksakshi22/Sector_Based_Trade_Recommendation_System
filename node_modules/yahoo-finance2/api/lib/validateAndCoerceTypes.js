"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePath = exports.ajv = void 0;
const ajv_1 = __importDefault(require("ajv"));
const ajv_formats_1 = __importDefault(require("ajv-formats"));
//import schema from '../../schema.json';
const schema = require("../../schema.json");
const pkg = require("../../package.json");
const errors_1 = require("./errors");
// https://ajv.js.org/docs/api.html#options
exports.ajv = new ajv_1.default({
    // All rules, all errors.  Don't end early after first error.
    allErrors: true,
    // Allow multiple non-null types, like in TypeSript.
    allowUnionTypes: true,
});
ajv_formats_1.default(exports.ajv);
exports.ajv.addKeyword({
    keyword: "yahooFinanceType",
    modifying: true,
    errors: true,
    schema: true,
    compile(schema /*, parentSchema, it */) {
        const validate = (data, dataCtx) => {
            const { parentData, parentDataProperty } = dataCtx;
            function set(value) {
                parentData[parentDataProperty] = value;
                return true;
            }
            if (schema === "number" || schema === "number|null") {
                if (typeof data === "number")
                    return true;
                if (typeof data === "string") {
                    let float = Number.parseFloat(data);
                    if (Number.isNaN(float)) {
                        validate.errors = validate.errors || [];
                        validate.errors.push({
                            keyword: "yahooFinanceType",
                            message: "Number.parseFloat returned NaN",
                            params: { schema, data },
                        });
                        return false;
                    }
                    return set(float);
                }
                if (data === null) {
                    if (schema === "number|null") {
                        return true;
                    }
                    else {
                        validate.errors = validate.errors || [];
                        validate.errors.push({
                            keyword: "yahooFinanceType",
                            message: "Expecting number'ish but got null",
                            params: { schema, data },
                        });
                        return false;
                    }
                }
                if (typeof data === "object") {
                    if (Object.keys(data).length === 0) {
                        // Value of {} becomes null
                        // Note, TypeScript types should be "number | null"
                        if (schema === "number|null") {
                            return set(null);
                        }
                        else {
                            validate.errors = validate.errors || [];
                            validate.errors.push({
                                keyword: "yahooFinanceType",
                                message: "Got {}->null for 'number', did you want 'number | null' ?",
                                params: { schema, data },
                            });
                            return false;
                        }
                    }
                    if (typeof data.raw === "number")
                        return set(data.raw);
                }
            }
            else if (schema === "date") {
                if (data instanceof Date) {
                    // Validate existing date objects.
                    // Generally we receive JSON but in the case of "historical", the
                    // csv parser does the date conversion, and we want to validate
                    // afterwards.
                    return true;
                }
                if (typeof data === "number")
                    return set(new Date(data * 1000));
                if (data === null)
                    return set(null);
                if (typeof data === "object" && typeof data.raw === "number")
                    return set(new Date(data.raw * 1000));
                if (typeof data === "string") {
                    if (data.match(/^\d{4,4}-\d{2,2}-\d{2,2}$/) ||
                        data.match(/^\d{4,4}-\d{2,2}-\d{2,2}T\d{2,2}:\d{2,2}:\d{2,2}\.\d{3,3}Z$/))
                        return set(new Date(data));
                }
            }
            else if (schema === "DateInMs") {
                return set(new Date(data));
            }
            else if (schema === "TwoNumberRange") {
                if (typeof data === "object" &&
                    typeof data.low === "number" &&
                    typeof data.high === "number")
                    return true;
                if (typeof data === "string") {
                    const parts = data.split("-").map(parseFloat);
                    if (Number.isNaN(parts[0]) || Number.isNaN(parts[1])) {
                        validate.errors = validate.errors || [];
                        validate.errors.push({
                            keyword: "yahooFinanceType",
                            message: "Number.parseFloat returned NaN: [" + parts.join(",") + "]",
                            params: { schema, data },
                        });
                        return false;
                    }
                    return set({ low: parts[0], high: parts[1] });
                }
            }
            else {
                throw new Error("No such yahooFinanceType: " + schema);
            }
            validate.errors = validate.errors || [];
            validate.errors.push({
                keyword: "yahooFinanceType",
                message: "No matching type",
                params: { schema, data },
            });
            return false;
        };
        return validate;
    },
});
exports.ajv.addSchema(schema);
/* istanbul ignore next */
const logObj = typeof process !== "undefined" && ((_a = process === null || process === void 0 ? void 0 : process.stdout) === null || _a === void 0 ? void 0 : _a.isTTY)
    ? (obj) => console.dir(obj, { depth: 4, colors: true })
    : (obj) => console.log(JSON.stringify(obj, null, 2));
function resolvePath(obj, instancePath) {
    const path = instancePath.split("/");
    let ref = obj;
    for (let i = 1; i < path.length; i++)
        ref = ref[path[i]];
    return ref;
}
exports.resolvePath = resolvePath;
function validate({ source, type, object, schemaKey, options, }) {
    const validator = exports.ajv.getSchema(schemaKey);
    if (!validator)
        throw new Error("No such schema with key: " + schemaKey);
    const valid = validator(object);
    if (valid)
        return;
    if (type === "result") {
        /* istanbul ignore else */
        if (validator.errors)
            validator.errors.forEach((error) => {
                // For now let's ignore the base object which could be huge.
                /* istanbul ignore else */
                if (error.instancePath !== "")
                    // Note, not the regular ajv data value from verbose:true
                    error.data = resolvePath(object, error.instancePath);
            });
        if (options.logErrors) {
            const title = encodeURIComponent("Failed validation: " + schemaKey);
            console.log("The following result did not validate with schema: " + schemaKey);
            logObj(validator.errors);
            // logObj(object);
            console.log(`
This may happen intermittently and you should catch errors appropriately.
However:  1) if this recently started happening on every request for a symbol
that used to work, Yahoo may have changed their API.  2) If this happens on
every request for a symbol you've never used before, but not for other
symbols, you've found an edge-case.  Please see if anyone has reported
this previously:

  ${pkg.repository}/issues?q=is%3Aissue+${title}

or open a new issue (and mention the symbol):

  ${pkg.repository}/issues/new?title=${title}

For information on how to turn off the above logging or skip these errors,
see https://github.com/gadicc/node-yahoo-finance2/tree/devel/docs/validation.md.
`);
        } /* if (logErrors) */
        throw new errors_1.FailedYahooValidationError("Failed Yahoo Schema validation", {
            result: object,
            errors: validator.errors,
        });
    } /* if (type === 'options') */
    else {
        if (options.logOptionsErrors) {
            console.error(`[yahooFinance.${source}] Invalid options ("${schemaKey}")`);
            logObj({ errors: validator.errors, input: object });
        }
        throw new errors_1.InvalidOptionsError(`yahooFinance.${source} called with invalid options.`);
    }
}
exports.default = validate;
